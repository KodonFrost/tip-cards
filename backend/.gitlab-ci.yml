# ------------- INFO
# Cache is deleted after completion of the pipeline which means: ⚠️ THIS PIPELINE CANNOT RUN TWICE

# ------------- SETUP
# - DEPLOY_SERVER_MAIN
# - DEPLOY_SERVER_DEVELOP
# - DEPLOY_USER
# - DEPLOY_USER_SSH_KEY # can be found in sate access
# - DEPLOY_PATH_MAIN
# - DEPLOY_PATH_DEVELOP
# - PM2_APP_NAME_MAIN # used to identifiy in ecosystem.config.js
# - PM2_APP_NAME_DEVELOP # used to identifiy in ecosystem.config.js
# - ENV_FILE_MAIN
# - ENV_FILE_DEVELOP

# ------------- PIPELINE
# Current Node Version on BFR Review Server
image: node:16.14-alpine

# List of stages for jobs, and their order of execution
stages:
  - setup
  - install
  - test
  - deploy
  - cleanup
  - integration

  # ------------- BASE CONFIG OF THE JOBS
# Define a hidden job to be used with extends
# 1) Key for the cache is current package-lock.json
#    Cache is deleted after completion of the pipeline which means: ⚠️ THIS PIPELINE CANNOT RUN TWICE
#    Better than default to avoid activating cache for all jobs
# 2) Globally define only run on main & develop and NOT on schedule
.base_config:
  rules:
    ### Sources
    # push   For pipelines triggered by a git push event, including for branches and tags.
    # web    For pipelines created by using Run pipeline button in the GitLab UI, from the project’s CI/CD > Pipelines section.
    - if: $CI_PIPELINE_SOURCE != 'push' && $CI_PIPELINE_SOURCE != 'web'
      when: never
    - when: on_success
  cache:
    key:
      files:
        - package-lock.json
    paths:
      - .npm
      - node_modules
      - .env
      - ecosystem.config.js
    # only pull the cache (that will be setup by the "setup-job")
    policy: pull

# Create Artifact with current ref or tag name (using the slug)
.artifacts_config:
  artifacts:
    name: "$CI_COMMIT_REF_SLUG"
    paths:
      - build
      - node_modules
      - .env
      - ecosystem.config.js

# Branches which have an deploy environment
.deployable_branches_rules:
  rules:
    - if: $CI_COMMIT_BRANCH != 'main' && $CI_COMMIT_BRANCH != 'develop'
      when: never

# ------------- STAGE SETUP

env-create-job:
  image: alpine
  stage: setup
  extends: .base_config
  rules:
    - !reference [.deployable_branches_rules, rules]
    - !reference [.base_config, rules]

  # Upload the cache after it's done
  cache:
    policy: pull-push
  script:
    # get the .env variables for the environment
    - if [ "$CI_COMMIT_BRANCH" == "main" ]; then export ENV_FILE=$ENV_FILE_MAIN; fi
    - if [ "$CI_COMMIT_BRANCH" == "develop" ]; then export ENV_FILE=$ENV_FILE_DEVELOP; fi
    - |
      # Check if env file exists
      if [ -f "$ENV_FILE" ]; then
        cp $ENV_FILE .env
      else
        echo -e "\e[31mERROR:ENV_FILE_[ENVIRONMENT/BRANCH] not set in Gitlab CI/CD variables\e[0m"
        exit 1
      fi
    # Compare env vars with .env.example
    - |
     cat .env.example | while read line; do
        # Exclude non key=var lines
        if [[ "$line" != *\=* ]]; then continue; fi
        # String split to KEY and VALUE
        savedIFS="$IFS"
        IFS="\="
        set x $line
        KEY=$2
        IFS="$savedIFS"
        # Find key in .env file
        echo "Checking: $KEY"
        if grep -Fq "$KEY=" .env
        then
          echo "✅ $KEY"
        else
          echo -e "\e[31mERROR:ENV variable $KEY not set in Gitlab CI/CD variables\e[0m"
          exit 1
        fi	
      done

# ------------- STAGE INSTALL

npm-ci-job:
  stage: install
  extends: .base_config
  # Upload the cache after it's done
  cache:
    policy: pull-push
  script:
    - npm ci

# ------------- STAGE TEST

audit-job:
  stage: test
  extends: .base_config
  script:
    - npm audit

unit-test-job:
  stage: test
  extends: .base_config
  script:
    - npm run test-units

# ------------- STAGE DEPLOY (& BUILD)

build-job:
  stage: deploy
  extends:
    - .base_config
    - .artifacts_config
  script:
    - npm run build


.deploy_config:
  image: alpine
  stage: deploy
  needs: [build-job]
  variables:
    NODE_ENV: production
    GIT_STRATEGY: none
  extends:
    - .base_config
    - .artifacts_config

  # Disable Cache
  cache: {}

  before_script:
    - apk update && apk add openssh-client rsync
    - mkdir ~/.ssh
    - echo -e "Host *\n\tStrictHostKeyChecking no" >> ~/.ssh/config
    - cat ~/.ssh/config
    - eval $(ssh-agent -s)
    - echo "$DEPLOY_USER_SSH_KEY" | ssh-add -

  script:
    - |  
      if [ "$CI_COMMIT_BRANCH" == "main" ]
      then 
        echo "Deploying on Environment Main"
        export DEPLOY_SERVER=$DEPLOY_SERVER_MAIN
        export DEPLOY_PATH=$DEPLOY_PATH_MAIN
        export PM2_APP_NAME=$PM2_APP_NAME_MAIN
      elif [ "$CI_COMMIT_BRANCH" == "develop" ]
      then
        echo "Deploying on Environment Develop"
        export DEPLOY_SERVER=$DEPLOY_SERVER_DEVELOP
        export DEPLOY_PATH=$DEPLOY_PATH_DEVELOP
        export PM2_APP_NAME=$PM2_APP_NAME_DEVELOP
      else
        # Safety if another branch accedently triggers this job
        echo "ERROR: this branch $CI_COMMIT_BRANCH is not allowed to run this job! Wake up your devops team!"
        exit 1
      fi
    - echo "Deploying with user $DEPLOY_USER on server $DEPLOY_SERVER to path $DEPLOY_PATH"
    # RSYNC Dist
    - rsync -atv --delete --progress  ./ $DEPLOY_USER@$DEPLOY_SERVER:$DEPLOY_PATH/dist-next
    - | 
      ssh $DEPLOY_USER@$DEPLOY_SERVER /bin/bash -s << EOT
      
      # 1) Stop pm2
      if [ -d $DEPLOY_PATH/dist-node ]; then
        cd $DEPLOY_PATH/dist-node
        PM2_HOME=/var/www/.pm2/ pm2 delete ecosystem.config.js --only $PM2_APP_NAME
        cd $DEPLOY_PATH
      else
        echo "No $DEPLOY_PATH/dist-node dir found, skipping pm2 delete"
      fi

      # 2) Remove old dist-previous dir
      rm -rf $DEPLOY_PATH/dist-previous

      # 3) Save current dist to previous
      if [ -d $DEPLOY_PATH/dist-node ]; then
        mv $DEPLOY_PATH/dist-node $DEPLOY_PATH/dist-previous
      fi

      # 4) Make new dist available
      mv $DEPLOY_PATH/dist-next $DEPLOY_PATH/dist-node

      # 5) Start pm2
      cd $DEPLOY_PATH/dist-node      
      PM2_HOME=/var/www/.pm2/ pm2 start ecosystem.config.js --only $PM2_APP_NAME

      # 6) save pm2
      PM2_HOME=/var/www/.pm2/ pm2 save
      
      EOT

deploy-develop-job:
  extends:
  - .deploy_config
  environment:
    name: develop
  rules:
    - if: $CI_COMMIT_BRANCH != 'develop'
      when: never
    - !reference [.base_config, rules]

deploy-main-job:
  extends:
  - .deploy_config
  environment:
    name: main
  rules:
    - if: $CI_COMMIT_BRANCH != 'main'
      when: never
    - !reference [.base_config, rules]

# ------------- STAGE CLEANUP

cleanup-job:
  image: alpine
  stage: cleanup
  extends: .base_config
  script:
    - echo "Cleaning up the cache"
    - rm -rf "%CACHE_PATH%/%CI_PIPELINE_ID%"
  when: on_success

  # ------------- STAGE INTEGRATION

integration-test-job:
  stage: integration

  # Disable Cache
  cache: {}

  variables:
    NODE_ENV: test

  rules:
    - !reference [.deployable_branches_rules, rules]
    # Exclude other schedules
    - if: $CI_PIPELINE_SOURCE == 'schedule' && $SCHEDULE_JOB != 'NIGHTLY_INTEGRATION'
      when: never
    # Only run the job if its manual (web), commit push or scheduled
    - if: $CI_PIPELINE_SOURCE == 'web' || $CI_PIPELINE_SOURCE == 'push' || $CI_PIPELINE_SOURCE == 'schedule'
      when: on_success
    - when: never

  script:
    - |
      if [ "$CI_COMMIT_BRANCH" == "main" ]
      then 
        echo "Running on Main Branch"
        export ENV_FILE=$ENV_FILE_MAIN
      elif [ "$CI_COMMIT_BRANCH" == "develop" ]
      then
        echo "Running on develop Branch"
        export ENV_FILE=$ENV_FILE_DEVELOP
      else
        echo "ERROR: this branch $CI_COMMIT_BRANCH is not allowed to run this job! Wake up your devops team!"
        # Safety if another branch accedently triggers this job
        exit 1
      fi
      
      # Check if env file exists
      if [ -f "$ENV_FILE" ]; then
        cp $ENV_FILE .env
      else
        echo -e "\e[31mERROR:ENV_FILE_[ENVIRONMENT/BRANCH] not set in Gitlab CI/CD variables\e[0m"
        exit 1
      fi
    - echo "Running Intergration Test on branch $CI_COMMIT_BRANCH with url $TEST_ORIGIN"
    - npm ci --include=dev
    - npm run test-integration
